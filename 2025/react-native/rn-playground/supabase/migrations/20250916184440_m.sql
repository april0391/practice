create schema if not exists "app";

create type "app"."user_role" as enum ('buyer', 'seller');

create table "app"."products" (
    "id" integer generated by default as identity not null,
    "name" text not null,
    "description" text
);


create table "app"."profiles" (
    "id" uuid not null,
    "avatar_url" text,
    "role" app.user_role not null
);


create table "app"."transactions" (
    "id" uuid not null default gen_random_uuid(),
    "buyer_id" uuid not null,
    "seller_id" uuid not null,
    "amount" integer not null
);


CREATE UNIQUE INDEX products_pkey ON app.products USING btree (id);

CREATE UNIQUE INDEX profiles_pkey ON app.profiles USING btree (id);

CREATE UNIQUE INDEX transactions_pkey ON app.transactions USING btree (id);

alter table "app"."products" add constraint "products_pkey" PRIMARY KEY using index "products_pkey";

alter table "app"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "app"."transactions" add constraint "transactions_pkey" PRIMARY KEY using index "transactions_pkey";

alter table "app"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "app"."profiles" validate constraint "profiles_id_fkey";

alter table "app"."transactions" add constraint "transactions_buyer_id_fkey" FOREIGN KEY (buyer_id) REFERENCES auth.users(id) not valid;

alter table "app"."transactions" validate constraint "transactions_buyer_id_fkey";

alter table "app"."transactions" add constraint "transactions_seller_id_fkey" FOREIGN KEY (seller_id) REFERENCES auth.users(id) not valid;

alter table "app"."transactions" validate constraint "transactions_seller_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION app.custom_access_token_hook(event jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
  declare
    original_claims jsonb;
    new_claims jsonb;
    claim text;
    user_role text;
  begin
    original_claims = event->'claims';
    new_claims = '{}'::jsonb;

    foreach claim in array array[
      -- add claims you want to keep here
      'iss',
      'aud',
      'exp',
      'iat',
      'sub',
      'role',
      'aal',
      'session_id',
      'email',
      'phone',
      'app_metadata',
      'user_metadata',
      'is_anonymous'
   ] loop
      if original_claims ? claim then
        -- original_claims contains one of the listed claims, set it on new_claims
        new_claims = jsonb_set(new_claims, array[claim], original_claims->claim);
      end if;
    end loop;

    select role 
    into user_role
    from app.profiles 
    where id = (event->>'user_id')::uuid;

    new_claims = jsonb_set(new_claims, array['user_role'], to_jsonb(user_role));

    return jsonb_build_object('claims', new_claims);
  end
$function$
;

CREATE OR REPLACE FUNCTION app.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
begin
  insert into app.profiles (id, avatar_url, role)
  values (
    new.id,
    new.raw_user_meta_data -> 'init_data' ->> 'avatar_url',
    (new.raw_user_meta_data -> 'init_data' ->> 'role')::app.user_role
  );

  update auth.users
  set raw_user_meta_data = '{"init_data": ""}'::jsonb
  where id = NEW.id;

  return new;
end;
$function$
;

grant select on table "app"."profiles" to "supabase_auth_admin";


